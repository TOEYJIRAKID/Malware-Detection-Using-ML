from tabulate import tabulate
import pandas as pd
import joblib
import pefile
import time
import sys
import os

def extract_data(name, pe):

    entropy = map(lambda x: x.get_entropy(), pe.sections)
    raw_sizes = map(lambda x: x.SizeOfRawData, pe.sections)
    virtual_sizes = map(lambda x: x.Misc_VirtualSize, pe.sections)
    physical_address = map(lambda x: x.Misc_PhysicalAddress, pe.sections)
    virtual_address = map(lambda x: x.VirtualAddress, pe.sections)
    pointer_raw_data = map(lambda x: x.PointerToRawData, pe.sections)
    characteristics = map(lambda x: x.Characteristics, pe.sections)

    data = {
            'Name': name,
            'e_magic': pe.DOS_HEADER.e_magic,
            'e_cblp': pe.DOS_HEADER.e_cblp,
            'e_cp': pe.DOS_HEADER.e_cp,
            'e_crlc': pe.DOS_HEADER.e_crlc,
            'e_cparhdr': pe.DOS_HEADER.e_cparhdr,
            'e_minalloc': pe.DOS_HEADER.e_minalloc,
            'e_maxalloc': pe.DOS_HEADER.e_maxalloc,
            'e_ss': pe.DOS_HEADER.e_ss,
            'e_sp': pe.DOS_HEADER.e_sp,
            'e_csum': pe.DOS_HEADER.e_csum,
            'e_ip': pe.DOS_HEADER.e_ip,
            'e_cs': pe.DOS_HEADER.e_cs,
            'e_lfarlc': pe.DOS_HEADER.e_lfarlc,
            'e_ovno': pe.DOS_HEADER.e_ovno,
            'e_oemid': pe.DOS_HEADER.e_oemid,
            'e_oeminfo': pe.DOS_HEADER.e_oeminfo,
            'e_lfanew': pe.DOS_HEADER.e_lfanew,
            'Machine': pe.FILE_HEADER.Machine,
            'NumberOfSections': pe.FILE_HEADER.NumberOfSections,
            'TimeDateStamp': pe.FILE_HEADER.TimeDateStamp,
            'PointerToSymbolTable': pe.FILE_HEADER.PointerToSymbolTable,
            'NumberOfSymbols': pe.FILE_HEADER.NumberOfSymbols,
            'SizeOfOptionalHeader': pe.FILE_HEADER.SizeOfOptionalHeader,
            'Characteristics': pe.FILE_HEADER.Characteristics,
            'Magic': pe.OPTIONAL_HEADER.Magic,
            'MajorLinkerVersion': pe.OPTIONAL_HEADER.MajorLinkerVersion,
            'MinorLinkerVersion': pe.OPTIONAL_HEADER.MinorLinkerVersion,
            'SizeOfCode': pe.OPTIONAL_HEADER.SizeOfCode,
            'SizeOfInitializedData': pe.OPTIONAL_HEADER.SizeOfInitializedData,
            'SizeOfUninitializedData': pe.OPTIONAL_HEADER.SizeOfUninitializedData,
            'AddressOfEntryPoint': pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            'BaseOfCode': pe.OPTIONAL_HEADER.BaseOfCode,
            'ImageBase': pe.OPTIONAL_HEADER.ImageBase,
            'SectionAlignment': pe.OPTIONAL_HEADER.SectionAlignment,
            'FileAlignment': pe.OPTIONAL_HEADER.FileAlignment,
            'MajorOperatingSystemVersion': pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
            'MinorOperatingSystemVersion': pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
            'MajorImageVersion': pe.OPTIONAL_HEADER.MajorImageVersion,
            'MinorImageVersion': pe.OPTIONAL_HEADER.MinorImageVersion,
            'MajorSubsystemVersion': pe.OPTIONAL_HEADER.MajorSubsystemVersion,
            'MinorSubsystemVersion': pe.OPTIONAL_HEADER.MinorSubsystemVersion,
            'SizeOfHeaders': pe.OPTIONAL_HEADER.SizeOfHeaders,
            'CheckSum': pe.OPTIONAL_HEADER.CheckSum,
            'SizeOfImage': pe.OPTIONAL_HEADER.SizeOfImage,
            'Subsystem': pe.OPTIONAL_HEADER.Subsystem,
            'DllCharacteristics': pe.OPTIONAL_HEADER.DllCharacteristics,
            'SizeOfStackReserve': pe.OPTIONAL_HEADER.SizeOfStackReserve,
            'SizeOfStackCommit': pe.OPTIONAL_HEADER.SizeOfStackCommit,
            'SizeOfHeapReserve': pe.OPTIONAL_HEADER.SizeOfHeapReserve,
            'SizeOfHeapCommit': pe.OPTIONAL_HEADER.SizeOfHeapCommit,
            'LoaderFlags': pe.OPTIONAL_HEADER.LoaderFlags,
            'NumberOfRvaAndSizes': pe.OPTIONAL_HEADER.NumberOfRvaAndSizes
            }
        
    try:
        data['SectionsLength'] = len(pe.sections)
    except (ValueError, TypeError):
        data['SectionsLength'] = 0
    try:
        data['SectionMinEntropy'] = min(entropy)
    except (ValueError, TypeError):
        data['SectionMinEntropy'] = 0
    try:
        data['SectionMaxEntropy'] = max(entropy)
    except (ValueError, TypeError):
        data['SectionMaxEntropy'] = 0
    try:
        data['SectionMinRawsize'] = min(raw_sizes)
    except (ValueError, TypeError):
        data['SectionMinRawsize'] = 0
    try:
        data['SectionMaxRawsize'] = max(raw_sizes)
    except (ValueError, TypeError):
        data['SectionMaxRawsize'] = 0
    try:
        data['SectionMinVirtualsize'] = min(virtual_sizes)
    except (ValueError, TypeError):
        data['SectionMinVirtualsize'] = 0
    try:
        data['SectionMaxVirtualsize'] = max(virtual_sizes)
    except (ValueError, TypeError):
        data['SectionMaxVirtualsize'] = 0
    try:
        data['SectionMaxVirtualsize'] = max(virtual_sizes)
    except (ValueError, TypeError):
        data['SectionMaxVirtualsize'] = 0

    try:
        data['SectionMaxPhysical'] = max(physical_address)
    except (ValueError, TypeError):
        data['SectionMaxPhysical'] = 0
    try:
        data['SectionMinPhysical'] = min(physical_address)
    except (ValueError, TypeError):
        data['SectionMinPhysical'] = 0

    try:
        data['SectionMaxVirtual'] = max(virtual_address)
    except (ValueError, TypeError):
        data['SectionMaxVirtual'] = 0
    try:
        data['SectionMinVirtual'] = min(virtual_address)
    except (ValueError, TypeError):
        data['SectionMinVirtual'] = 0

    try:
        data['SectionMaxPointerData'] = max(pointer_raw_data)
    except (ValueError, TypeError):
        data['SectionMaxPointerData'] = 0

    try:
        data['SectionMinPointerData'] = min(pointer_raw_data)
    except (ValueError, TypeError):
        data['SectionMinPointerData'] = 0

    try:
        data['SectionMaxChar'] = max(characteristics)
    except (ValueError, TypeError):
        data['SectionMaxChar'] = 0

    try:
        data['SectionMinChar'] = min(characteristics)
    except (ValueError, TypeError):
        data['SectionMainChar'] = 0

    try:
        data['DirectoryEntryImport'] = (len(pe.DIRECTORY_ENTRY_IMPORT))
        imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
        data['DirectoryEntryImportSize'] = (len(imports))
    except AttributeError:
        data['DirectoryEntryImport'] = 0
        data['DirectoryEntryImportSize'] = 0
    
    try:
        data['DirectoryEntryExport'] = (len(pe.DIRECTORY_ENTRY_EXPORT.symbols))
    except AttributeError:
        
        data['DirectoryEntryExport'] = 0

    data['ImageDirectoryEntryExport'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT']].VirtualAddress
    data['ImageDirectoryEntryImport'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']].VirtualAddress
    data['ImageDirectoryEntryResource'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_RESOURCE']].VirtualAddress
    data['ImageDirectoryEntryException'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXCEPTION']].VirtualAddress
    data['ImageDirectoryEntrySecurity'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress

    return data

def predict(pkl_file, test_data):

    data = pd.DataFrame(test_data, index=[0])

    features_list = ['DllCharacteristics', 'Characteristics', 'MajorLinkerVersion', 'SizeOfInitializedData', 'ImageBase', 'SectionMinRawsize', 'SectionMinEntropy', 'MinorOperatingSystemVersion', 'SectionMinVirtualsize', 'SizeOfStackReserve', 'MinorImageVersion', 'ImageDirectoryEntryImport', 'SizeOfCode', 'MajorSubsystemVersion', 'ImageDirectoryEntryResource', 'SectionMaxPhysical', 'SectionMaxPointerData', 'CheckSum', 'MajorOperatingSystemVersion', 'SizeOfImage', 'AddressOfEntryPoint', 'SectionMaxVirtual', 'MinorSubsystemVersion', 'e_lfanew', 'Subsystem', 'ImageDirectoryEntryExport', 'DirectoryEntryImportSize', 'SectionMaxChar', 'DirectoryEntryExport', 'MajorImageVersion', 'ImageDirectoryEntrySecurity', 'DirectoryEntryImport', 'SizeOfHeaders', 'SectionsLength', 'NumberOfSections', 'MinorLinkerVersion', 'BaseOfCode', 'SizeOfUninitializedData', 'e_cblp', 'SizeOfStackCommit', 'ImageDirectoryEntryException', 'Magic', 'SizeOfOptionalHeader', 'FileAlignment', 'e_cp', 'Machine', 'e_minalloc', 'e_ovno', 'SizeOfHeapReserve', 'e_sp', 'e_maxalloc', 'SectionAlignment', 'e_cparhdr', 'SizeOfHeapCommit', 'e_lfarlc', 'SectionMainChar', 'SectionMinPointerData', 'e_oeminfo', 'e_ip', 'SectionMaxVirtualsize', 'e_oemid', 'LoaderFlags', 'NumberOfSymbols', 'PointerToSymbolTable', 'NumberOfRvaAndSizes', 'SectionMinPhysical', 'e_cs', 'e_magic', 'SectionMaxRawsize']
    X_test = data[features_list]
    
    load_model = joblib.load(pkl_file)

    X_t = load_model.named_steps['scale'].transform(X_test)
    y_testing_pred = load_model.named_steps['clf'].predict_proba(X_t)

    y_testing_pred = pd.DataFrame(y_testing_pred, columns=["not malware(%)", "malware(%)"])
    y_testing_pred = (y_testing_pred * 100).round(2)

    X_to_push = data

    X_to_push['Name'] = X_to_push['Name'].str.slice(0, 20)
    result_df = pd.concat([X_to_push['Name'], y_testing_pred], axis=1)
    return result_df

def main(pkl_file, *file_paths):
    
    for filePath in file_paths:
        if not os.path.exists(filePath):
            print(f"File not found: {filePath}")
            continue

        pe = pefile.PE(filePath)
        t1 = round(time.time() * 1000, 4)
        extracted_data = extract_data(filePath, pe)
        t2 = round(time.time() * 1000, 4)
        model_predict = predict(pkl_file, extracted_data)
        result_df = model_predict
        t3 = round(time.time() * 1000, 4)
        state1 = round(t2 - t1, 4)
        state2 = round(t3 - t2, 4)

        prediction = "Benign" if result_df.iloc[0, 1] > result_df.iloc[0, 2] else "Malware"
        table_data = [
            ["PKL FILE", pkl_file],
            ["Name", result_df.iloc[0, 0]],
            ["Benign(%)", result_df.iloc[0, 1]],
            ["Malware(%)", result_df.iloc[0, 2]],
            ["Predict", prediction],
            ["Read PE Speed", f"{state1} ms"],
            ["Predict Speed", f"{state2} ms"]
        ]

        result = print(f"\nFile: {filePath} is {prediction}")
        result_table = print(tabulate(table_data, headers="firstrow", tablefmt="fancy_grid"))

        return result, result_table

if __name__ == "__main__":
    n = len(sys.argv)
    if n < 3:
        print("Usage: python main.py model.pkl pe_file1 pe_file..")
        exit()

    pkl_file = sys.argv[1]
    file_paths = sys.argv[2:]
    main(pkl_file, *file_paths)